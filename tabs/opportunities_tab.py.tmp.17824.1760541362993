"""
Enhanced Opportunities Tab - With Multi-Supplier Allocation Support AND Sales Period Filter
Compatible with both manual upload and automatic file loading
UPDATED: Only Priority 1 and 2 (Priority 3 eliminated), Stock Average Price column added, Sales Period Filter
"""

import streamlit as st
import pandas as pd
from datetime import datetime
from typing import List, Dict, Any
from utils import pad_ean_code


def get_safe_allocated_quantity(opp: Dict) -> int:
    """
    Get allocated quantity with safe fallback that respects supplier constraints
    CRITICAL: This prevents allocating more than supplier has available
    """
    # If allocated_quantity exists and is valid, use it
    if "allocated_quantity" in opp and opp["allocated_quantity"] is not None:
        return opp["allocated_quantity"]

    # Calculate safe fallback that respects supplier quantity constraint
    net_need = opp.get("net_need", 0)
    supplier_qty = opp.get("supplier_quantity")

    if supplier_qty is not None and supplier_qty >= 0:
        # CRITICAL: Never allocate more than supplier has available
        return min(supplier_qty, net_need)
    else:
        # Only use net_need if supplier quantity is unknown
        return net_need


def recalculate_net_need_for_period(opp: Dict, sales_period: str) -> int:
    """
    Recalculate net need based on selected sales period INCLUDING qntPendingToDeliver
    UPDATED: New formula: sales - current_stock - qntPendingToDeliver
    """
    current_stock = opp.get("current_stock", 0)
    qnt_pending_to_deliver = opp.get("qntPendingToDeliver", 0)

    # Get sales for the selected period
    if sales_period == "sales90d":
        sales = opp.get("sales90d", 0)
    elif sales_period == "sales180d":
        sales = opp.get("sales180d", 0)
    elif sales_period == "sales365d":
        sales = opp.get("sales365d", 0)
    else:
        sales = opp.get("sales90d", 0)  # Default fallback

    # Updated formula: sales - current_stock - qntPendingToDeliver
    net_need = max(0, sales - current_stock - qnt_pending_to_deliver)
    return net_need


def calculate_net_need_for_custom_days(opp: Dict, custom_days: int) -> int:
    """
    Calculate net need for a custom number of days by extrapolating from available sales data.
    Uses the closest available sales period for most accurate estimation.

    Args:
        opp: Opportunity dictionary with sales data
        custom_days: Number of days to calculate net need for (1-365)

    Returns:
        Estimated net need for the custom period
    """
    if not custom_days or custom_days <= 0:
        return 0

    current_stock = opp.get("current_stock", 0)
    qnt_pending_to_deliver = opp.get("qntPendingToDeliver", 0)

    # Get available sales data
    sales90d = opp.get("sales90d", 0)
    sales180d = opp.get("sales180d", 0)
    sales365d = opp.get("sales365d", 0)

    # Choose the best sales period to extrapolate from based on custom_days
    # Use the closest period that is >= custom_days when possible
    estimated_sales = 0

    if custom_days <= 90 and sales90d > 0:
        # Use 90-day data for periods up to 90 days
        estimated_sales = (sales90d / 90) * custom_days
    elif custom_days <= 180 and sales180d > 0:
        # Use 180-day data for periods between 91-180 days
        estimated_sales = (sales180d / 180) * custom_days
    elif sales365d > 0:
        # Use 365-day data for longer periods or when others unavailable
        estimated_sales = (sales365d / 365) * custom_days
    elif sales180d > 0:
        # Fallback to 180 if 365 not available
        estimated_sales = (sales180d / 180) * custom_days
    elif sales90d > 0:
        # Last resort: extrapolate from 90-day data
        estimated_sales = (sales90d / 90) * custom_days
    else:
        # No sales data available
        estimated_sales = 0

    # Round to nearest integer
    estimated_sales = int(round(estimated_sales))

    # Calculate net need: estimated_sales - current_stock - pending_delivery
    net_need = max(0, estimated_sales - current_stock - qnt_pending_to_deliver)

    return net_need


def recalculate_opportunity_with_new_period(opp: Dict, sales_period: str) -> Dict:
    """
    Recalculate opportunity metrics based on new sales period
    """
    # Create a copy to avoid modifying original
    new_opp = opp.copy()

    # Recalculate net need based on selected period
    new_net_need = recalculate_net_need_for_period(opp, sales_period)
    new_opp["net_need"] = new_net_need
    new_opp["calculated_with_period"] = sales_period

    # Recalculate allocated quantity based on new net need
    supplier_qty = opp.get("supplier_quantity")
    if supplier_qty is not None and supplier_qty >= 0:
        new_allocated_qty = min(supplier_qty, new_net_need)
    else:
        new_allocated_qty = new_net_need

    new_opp["allocated_quantity"] = new_allocated_qty

    # Recalculate total savings based on new allocated quantity
    savings_per_unit = opp.get("savings_per_unit", 0)
    new_total_savings = savings_per_unit * new_allocated_qty
    new_opp["total_savings"] = new_total_savings

    return new_opp


def opportunities_tab(groq_api_key, api_key_valid=False):
    """Main procurement opportunities tab - UPDATED: Only Priority 1 and 2, with Sales Period Filter"""

    st.header("üéØ Procurement Opportunities with Smart Allocation")
    st.info(
        "üí° **Smart Multi-Supplier Allocation**: Automatically splits orders when suppliers have quantity constraints\n"
        "üìä **Sales Period Filter**: Dynamically calculate Net Need based on different sales periods"
    )

    # Check if we have supplier data
    if not st.session_state.get("processed_data"):
        st.warning("‚ö†Ô∏è **Step 1**: Process supplier catalogs first")
        st.info(
            "Use either 'File Processing' or 'Auto File Loading' tab to load supplier data"
        )
        return

    # Initialize opportunity engine
    if "opportunity_engine" not in st.session_state:
        try:
            from analysis.opportunity_engine import SimpleOpportunityEngine

            st.session_state.opportunity_engine = SimpleOpportunityEngine()
        except ImportError:
            st.error(
                "‚ùå Opportunity engine not available. Please ensure all modules are installed."
            )
            return

    engine = st.session_state.opportunity_engine

    # Check if internal data is already loaded (from auto-loading)
    if hasattr(engine, "internal_data") and engine.internal_data:
        st.success(
            f"‚úÖ **Internal data already loaded**: {len(engine.internal_data)} products"
        )

        # Show quick summary
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Internal Products", len(engine.internal_data))
        with col2:
            bestsellers = sum(
                1 for p in engine.internal_data if p.get("is_bestseller", False)
            )
            st.metric("Bestsellers", bestsellers)
        with col3:
            total_stock = sum(p.get("stock", 0) for p in engine.internal_data)
            st.metric("Total Stock", f"{total_stock:,}")

        # Skip to opportunity analysis
        show_smart_opportunity_analysis(engine)
        return

    # Show manual upload section if no auto-loaded data
    st.subheader("üìä Upload Internal Data (Manual)")
    st.info(
        "üí° **Tip**: For automatic loading, use the 'Auto File Loading' tab ‚Üí 'Internal Data' section"
    )

    uploaded_file = st.file_uploader(
        "Upload Internal Product Data (CSV)",
        type=["csv"],
        help="Upload your internal product master data with EAN codes, stock, sales, and pricing information",
    )

    if uploaded_file:
        try:
            # Load and validate internal data
            with st.spinner("Loading internal product data..."):
                success = engine.load_internal_data(uploaded_file)

            if success:
                # Show data summary
                show_internal_data_summary(engine)
                show_smart_opportunity_analysis(engine)
            else:
                st.error(
                    "‚ùå Failed to load internal data. Please check your CSV format."
                )

        except Exception as e:
            st.error(f"‚ùå Error loading file: {str(e)}")


def show_internal_data_summary(engine):
    """Show summary of loaded internal data"""

    internal_data = engine.internal_data
    st.success(f"‚úÖ Loaded {len(internal_data)} internal products")

    # Calculate summary stats
    total_stock = sum(p.get("stock", 0) for p in internal_data)
    total_sales90d = sum(p.get("sales90d", 0) for p in internal_data)
    total_sales180d = sum(p.get("sales180d", 0) for p in internal_data)
    total_sales365d = sum(p.get("sales365d", 0) for p in internal_data)
    bestsellers = sum(1 for p in internal_data if p.get("is_bestseller", False))
    active_products = sum(1 for p in internal_data if p.get("is_active", True))

    # Count products with different price types
    with_stock_avg = sum(
        1
        for p in internal_data
        if p.get("stock_avg_price") is not None and p.get("stock_avg_price") > 0
    )
    with_supplier_price = sum(
        1
        for p in internal_data
        if p.get("supplier_price") is not None and p.get("supplier_price") > 0
    )
    with_best_buy = sum(
        1
        for p in internal_data
        if p.get("best_buy_price") is not None and p.get("best_buy_price") > 0
    )

    # Display metrics
    col1, col2, col3, col4, col5 = st.columns(5)

    with col1:
        st.metric("Total Products", len(internal_data))
    with col2:
        st.metric("Active Products", active_products)
    with col3:
        st.metric("Bestsellers (1-2)", bestsellers)
    with col4:
        st.metric("Total Stock", f"{total_stock:,}")
    with col5:
        st.metric("Sales 90d", f"{total_sales90d:,}")

    # Sales period summary
    st.subheader("üìä Sales Data Availability")
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        # Price availability moved here for space
        st.metric(
            "Stock Avg Price",
            with_stock_avg,
            # f"{with_stock_avg/len(internal_data)*100:.1f}%",
        )
    with col2:
        st.metric("Sales 90d", f"{total_sales90d:,}")
    with col3:
        st.metric("Sales 180d", f"{total_sales180d:,}")
    with col4:
        st.metric("Sales 365d", f"{total_sales365d:,}")

    # Show sample data
    with st.expander("üìã Sample Data Preview"):
        sample_data = []
        for product in internal_data[:5]:
            # Get the best price for display
            prices = []
            for price_field, price_value in [
                ("Stock Avg", product.get("stock_avg_price")),
                ("Supplier", product.get("supplier_price")),
                ("Best Buy", product.get("best_buy_price")),
            ]:
                if price_value is not None and price_value > 0:
                    prices.append(f"{price_field}: ‚Ç¨{price_value:.2f}")

            bestseller_info = ""
            if product.get("bestseller_rank"):
                rank = product.get("bestseller_rank")
                stars = "‚≠ê" * max(0, 5 - rank)
                bestseller_info = f"Rank {rank} {stars}"

            sample_data.append(
                {
                    "EAN": product["ean"],
                    "Description": (
                        (product.get("description", "")[:50] + "...")
                        if len(product.get("description", "")) > 50
                        else product.get("description", "N/A")
                    ),
                    "Brand": product.get("brand", "N/A"),
                    "Stock": product.get("stock", 0),
                    "Sales 90d": product.get("sales90d", 0),
                    "Sales 180d": product.get("sales180d", 0),
                    "Sales 365d": product.get("sales365d", 0),
                    "Prices Available": " | ".join(prices) if prices else "None",
                    "Bestseller": bestseller_info,
                }
            )

        st.dataframe(pd.DataFrame(sample_data), use_container_width=True)


def show_smart_opportunity_analysis(engine):
    """Show opportunity analysis interface with smart allocation and sales period filter"""

    st.subheader("üí∞ Smart Opportunity Analysis")

    # Get supplier data
    supplier_data = st.session_state.get("processed_data")

    if not supplier_data:
        st.warning(
            "‚ö†Ô∏è No supplier data available. Please process supplier catalogs first."
        )
        return

    # Calculate opportunities with smart allocation (only once)
    if not hasattr(engine, "opportunities") or not engine.opportunities:
        with st.spinner(
            "üß† Analyzing procurement opportunities with smart multi-supplier allocation (Quality Focus: Priority 1 & 2 only)..."
        ):
            try:
                opportunities = engine.find_opportunities(supplier_data)

                # Verify allocation worked
                try:
                    verification = engine.verify_allocation()
                    if not verification.get("allocation_success", False):
                        st.warning("‚ö†Ô∏è **Allocation Issues Detected!**")
                        st.write("**Issues found:**")
                        for issue in verification.get("allocation_issues", []):
                            st.write(f"- {issue}")
                    else:
                        st.success(
                            f"‚úÖ **Smart allocation successful!** {verification.get('split_orders', 0)} split orders created"
                        )

                except AttributeError:
                    # Fallback verification
                    st.info("üîß Using basic allocation verification...")

            except Exception as e:
                st.error(f"‚ùå Error during analysis: {str(e)}")
                return

        if not opportunities:
            st.info("‚ÑπÔ∏è No high-quality opportunities found. This could mean:")
            st.write("- No EAN matches between internal data and supplier quotes")
            st.write("- Supplier prices don't meet Priority 1 or 2 standards")
            st.write("- No net need (current stock covers sales)")
            st.write(
                "- **Quality Filter**: Lower-impact opportunities were filtered out"
            )

            # Show debug info
            with st.expander("üîç Debug Information"):
                st.write(f"**Internal products loaded:** {len(engine.internal_data)}")
                st.write(f"**Supplier products available:** {len(supplier_data)}")

                # Show sample EANs
                internal_eans = [p["ean"] for p in engine.internal_data[:10]]
                supplier_eans = []
                for sp in supplier_data[:10]:
                    if hasattr(sp, "ean_code") and sp.ean_code:
                        supplier_eans.append(str(sp.ean_code))

                st.write(f"**Sample Internal EANs:** {internal_eans}")
                st.write(f"**Sample Supplier EANs:** {supplier_eans}")
                st.write("**Priority Standards:**")
                st.write("- Priority 1: Quote beats ALL 3 internal prices")
                st.write(
                    "- Priority 2: Quote beats supplier AND stock avg (not bestbuy)"
                )
                st.write(
                    "- **Eliminated**: Opportunities that beat only 1 price (former Priority 3)"
                )

            return

    # Show enhanced opportunity summary with allocation info
    show_enhanced_allocation_summary(engine)

    # Show allocation verification
    show_allocation_status(engine)

    # Show filtering and opportunities WITH SALES PERIOD FILTER
    filtered_opportunities, custom_days = show_enhanced_allocation_filters(engine)

    # Show opportunities table with allocation details
    show_enhanced_allocation_table(filtered_opportunities, custom_days)

    # Show supplier analysis with allocation insights
    show_enhanced_allocation_supplier_analysis(engine)

    # Export options with allocation data
    show_allocation_export_options(filtered_opportunities)


def show_enhanced_allocation_filters(engine):
    """Show filtering options with Sales Period Filter - UPDATED: Added Brand Filter"""

    opportunities = engine.opportunities if hasattr(engine, "opportunities") else []

    with st.expander("üîç Filter Opportunities"):
        # First row - Sales Period Filter (prominent position)
        st.subheader("üìä Sales Period for Net Need Calculation")

        col1, col2, col3 = st.columns([1, 1, 2])

        with col1:
            sales_period_filter = st.selectbox(
                "Sales Period",
                options=["sales90d", "sales180d", "sales365d"],
                index=0,  # Default to 90 days
                format_func=lambda x: {
                    "sales90d": "90 Days",
                    "sales180d": "180 Days",
                    "sales365d": "365 Days",
                }.get(x, x),
                help="Select which sales period to use for Net Need calculation (Sales Period - Current Stock)",
                key="sales_period_filter",
            )

        with col2:
            # NEW: Custom days input for additional column
            custom_days_input = st.number_input(
                "Custom Days (for extra column)",
                min_value=1,
                max_value=365,
                value=None,
                step=1,
                help="Enter custom number of days to see an additional Net Need calculation column in the table",
                key="custom_days_filter",
                placeholder="e.g., 45, 120, 200",
            )

        with col3:
            # Show what this affects
            period_name = {
                "sales90d": "90 days",
                "sales180d": "180 days",
                "sales365d": "365 days",
            }.get(sales_period_filter, sales_period_filter)

            info_text = f"üìà **Net Need calculated as**: Sales in last {period_name} - Current Stock - Pending Deliveries"
            if custom_days_input:
                info_text += f"\n\nüéØ **Custom column**: Will show Net Need for {custom_days_input} days"

            st.info(info_text)

        st.divider()

        # Second row - Standard filters (updated with brand filter)
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            priority_filter = st.selectbox(
                "Priority Level",
                options=[None, 1, 2],  # REMOVED: 3
                format_func=lambda x: (
                    "All Priorities" if x is None else f"Priority {x}"
                ),
                help="Filter by opportunity priority level (only Priority 1 and 2 available)",
                key="priority_filter",
            )

        with col2:
            allocation_filter = st.selectbox(
                "Allocation Type",
                options=[None, "single_only", "split_only"],
                format_func=lambda x: {
                    None: "All Types",
                    "single_only": "Single Supplier Only",
                    "split_only": "Split Orders Only",
                }.get(x, x),
                help="Filter by allocation type",
                key="allocation_filter",
            )

        with col3:
            # NEW: Brand filter
            available_brands = sorted(
                set(
                    opp.get("brand", "").strip()
                    for opp in opportunities
                    if opp.get("brand", "").strip()
                )
            )
            if "" in [opp.get("brand", "") for opp in opportunities]:
                available_brands = ["All Brands", "Unknown/Empty"] + [
                    b for b in available_brands if b
                ]
            else:
                available_brands = ["All Brands"] + available_brands

            brand_filter = st.selectbox(
                "Brand",
                options=available_brands,
                help="Filter opportunities by product brand",
                key="brand_filter",
            )

        with col4:
            urgency_filter = st.selectbox(
                "Urgency Level",
                options=[None, "High", "Medium", "Low"],
                help="Filter by stock urgency level",
                key="urgency_filter",
            )

        # Third row - Numeric filters and checkboxes
        col1, col2, col3 = st.columns(3)

        with col1:
            min_savings = st.number_input(
                "Min Savings/Unit (‚Ç¨)",
                min_value=0.0,
                value=0.01,
                step=0.05,
                help="Minimum savings per unit in euros",
                key="min_savings_filter",
            )

        with col2:
            min_total = st.number_input(
                "Min Total Savings (‚Ç¨)",
                min_value=0.0,
                value=0.01,
                step=1.0,
                help="Minimum total savings in euros",
                key="min_total_filter",
            )

        with col3:
            bestsellers_only = st.checkbox(
                "Bestsellers Only",
                help="Show only bestselling products (rank 1-2)",
                key="bestsellers_filter",
            )

    # FIRST: Recalculate opportunities based on selected sales period
    recalculated_opportunities = []
    for opp in opportunities:
        new_opp = recalculate_opportunity_with_new_period(opp, sales_period_filter)
        recalculated_opportunities.append(new_opp)

    # THEN: Apply other filters to the recalculated opportunities
    try:
        filtered = engine.filter_opportunities(
            min_savings=min_savings,
            min_total_savings=min_total,
            urgency_filter=urgency_filter,
            bestsellers_only=bestsellers_only,
            priority_filter=priority_filter,
            allocation_type_filter=allocation_filter,
            brand_filter=brand_filter,
        )

        # Apply sales period recalculation to filtered results
        filtered_recalculated = []
        for opp in filtered:
            new_opp = recalculate_opportunity_with_new_period(opp, sales_period_filter)
            filtered_recalculated.append(new_opp)

        filtered = filtered_recalculated

    except:
        # Fallback if enhanced filter method not available
        filtered = recalculated_opportunities.copy()

        if priority_filter is not None:
            filtered = [
                opp for opp in filtered if opp.get("priority") == priority_filter
            ]
        if allocation_filter == "split_only":
            filtered = [opp for opp in filtered if opp.get("is_split_order", False)]
        elif allocation_filter == "single_only":
            filtered = [opp for opp in filtered if not opp.get("is_split_order", False)]
        if min_savings > 0:
            filtered = [
                opp for opp in filtered if opp.get("savings_per_unit", 0) >= min_savings
            ]
        if min_total > 0:
            filtered = [
                opp for opp in filtered if opp.get("total_savings", 0) >= min_total
            ]
        if urgency_filter:
            filtered = [
                opp for opp in filtered if opp.get("urgency_score") == urgency_filter
            ]
        if bestsellers_only:
            filtered = [opp for opp in filtered if opp.get("is_bestseller", False)]
        if brand_filter and brand_filter not in ["All Brands"]:
            if brand_filter == "Unknown/Empty":
                filtered = [opp for opp in filtered if not opp.get("brand", "").strip()]
            else:
                filtered = [
                    opp
                    for opp in filtered
                    if opp.get("brand", "").strip() == brand_filter
                ]

    # Show filtering results
    filter_info_parts = []

    if brand_filter and brand_filter not in ["All Brands"]:
        if brand_filter == "Unknown/Empty":
            filter_info_parts.append("products without brand info")
        else:
            filter_info_parts.append(f"'{brand_filter}' brand")

    if priority_filter is not None:
        filter_info_parts.append(f"Priority {priority_filter}")

    if allocation_filter:
        allocation_name = {
            "split_only": "split orders",
            "single_only": "single supplier orders",
        }.get(allocation_filter, allocation_filter)
        filter_info_parts.append(allocation_name)

    if urgency_filter:
        filter_info_parts.append(f"{urgency_filter.lower()} urgency")

    if bestsellers_only:
        filter_info_parts.append("bestsellers")

    if min_savings > 0:
        filter_info_parts.append(f"‚â•‚Ç¨{min_savings:.2f}/unit savings")

    if min_total > 0:
        filter_info_parts.append(f"‚â•‚Ç¨{min_total:.2f} total savings")

    if len(filtered) != len(opportunities):
        period_display = {
            "sales90d": "90 days",
            "sales180d": "180 days",
            "sales365d": "365 days",
        }.get(sales_period_filter, sales_period_filter)

        filter_description = ""
        if filter_info_parts:
            filter_description = f" (filtered by: {', '.join(filter_info_parts)})"

        st.info(
            f"‚ÑπÔ∏è Showing {len(filtered)} opportunities (filtered from {len(opportunities)} total){filter_description} with Net Need calculated as {period_display} Sales - Current Stock - Pending Deliveries"
            f"with Net Need calculated using {period_display} sales data"
        )
    else:
        period_display = {
            "sales90d": "90 days",
            "sales180d": "180 days",
            "sales365d": "365 days",
        }.get(sales_period_filter, sales_period_filter)

    # Show quality improvement message
    if len(opportunities) > 0:
        priority_1_count = sum(1 for opp in opportunities if opp.get("priority") == 1)
        priority_2_count = sum(1 for opp in opportunities if opp.get("priority") == 2)

        st.success(
            f"üéØ **Quality Focus**: {len(opportunities)} high-impact opportunities found "
            f"({priority_1_count} Priority 1, {priority_2_count} Priority 2) "
        )

    return filtered, custom_days_input


def show_enhanced_allocation_table(opportunities: List[Dict], custom_days: int = None):
    """Show opportunities table with all sales columns, qntPendingToDeliver, dynamic Net Need calculation AND Priority column AND Price Difference % AND Custom Days column"""

    if not opportunities:
        st.info("No opportunities match your filters.")
        return

    st.subheader(f"üìã Smart Allocation Results ({len(opportunities)} opportunities)")

    # Show which sales period is being used for Net Need
    if opportunities:
        sales_period_used = opportunities[0].get("calculated_with_period", "sales90d")
        period_display = {
            "sales90d": "90 days",
            "sales180d": "180 days",
            "sales365d": "365 days",
        }.get(sales_period_used, sales_period_used)

        st.info(f"üìä **Net Need calculated using**: {period_display} sales data")

    # Count allocation types
    split_orders = sum(1 for opp in opportunities if opp.get("is_split_order", False))
    single_orders = len(opportunities) - split_orders

    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Opportunities", len(opportunities))
    with col2:
        st.metric("üîÑ Split Orders", split_orders)
    with col3:
        st.metric("üì¶ Single Orders", single_orders)

    # Prepare data for display with all sales columns, qntPendingToDeliver, Priority column AND Price Difference %
    table_data = []
    for i, opp in enumerate(opportunities):
        # Truncate product name if too long
        product_name = opp.get("product_name", "N/A")
        if len(product_name) > 35:
            product_name = product_name[:35] + "..."

        # Format allocation info
        allocation_info = "üì¶ Single"
        if opp.get("is_split_order", False):
            rank = opp.get("split_order_rank", 1)
            allocated_qty = get_safe_allocated_quantity(opp)
            original_need = opp.get("original_net_need", opp.get("net_need", 0))
            allocation_info = f"üîÑ Split #{rank} ({allocated_qty}/{original_need})"

        # Format supplier quantity with constraint indicators
        supplier_qty = opp.get("supplier_quantity")
        qty_display = str(int(supplier_qty)) if supplier_qty is not None else "-"

        # Add quantity constraint indicators
        net_need = opp.get("net_need", 0)  # This is now the recalculated net need
        purchasable_qty = get_safe_allocated_quantity(opp)

        if supplier_qty is not None:
            if supplier_qty == 0:
                qty_display = "0 ‚ö†Ô∏è"
            elif supplier_qty < net_need:
                qty_display = f"{int(supplier_qty)} ‚ö†Ô∏è"
            elif supplier_qty >= net_need and net_need > 0:
                qty_display = f"{int(supplier_qty)} ‚úÖ"
            else:
                qty_display = str(int(supplier_qty))

        # Enhanced stock average price formatting
        stock_avg_price = opp.get("price_breakdown", {}).get("stock_avg_price")
        if stock_avg_price and stock_avg_price > 0:
            stock_avg_display = f"‚Ç¨{stock_avg_price:.2f}"
        else:
            stock_avg_display = "N/A"

        # Get detailed price breakdown for comparison
        price_breakdown = opp.get("price_breakdown", {})
        price_details = []
        if price_breakdown.get("beats_best_buy"):
            price_details.append("vs Best Buy ‚úÖ")
        if price_breakdown.get("beats_supplier"):
            price_details.append("vs Supplier ‚úÖ")
        if price_breakdown.get("beats_stock_avg"):
            price_details.append("vs Stock Avg ‚úÖ")

        # FORMAT PRIORITY COLUMN
        priority = opp.get("priority", 0)
        priority_label = opp.get("priority_label", "")

        if priority == 1:
            priority_display = "üî• P1"
        elif priority == 2:
            priority_display = "‚≠ê P2"
        else:
            priority_display = f"P{priority}" if priority else "N/A"

        # NEW: Calculate Price Difference Percentage
        baseline_price = opp.get("baseline_price", 0)
        quote_price = opp.get("quote_price", 0)

        if baseline_price and baseline_price > 0 and quote_price > 0:
            price_diff_percentage = (
                (baseline_price - quote_price) / baseline_price
            ) * 100
            price_diff_display = f"{price_diff_percentage:.1f}%"
            if price_diff_percentage > 0:
                price_diff_display = (
                    f"-{price_diff_display}"  # Downward arrow for savings
                )
            elif price_diff_percentage < 0:
                price_diff_display = (
                    f"+{abs(price_diff_percentage):.1f}%"  # Upward arrow for increase
                )
            else:
                price_diff_display = "0.0%"
        else:
            price_diff_display = "N/A"

        # Calculate custom days net need if custom_days is provided
        if custom_days and custom_days > 0:
            custom_net_need = calculate_net_need_for_custom_days(opp, custom_days)
            custom_days_display = custom_net_need
        else:
            custom_days_display = "N/A"

        table_data.append(
            {
                # ADD PRIORITY AS FIRST COLUMN
                "Priority": priority_display,
                "EAN": pad_ean_code(opp.get("ean", "")),
                "Product": product_name,
                "Brand": opp.get("brand", "N/A"),
                "Current Stock": opp.get("current_stock", 0),
                "Pending Delivery": opp.get("qntPendingToDeliver", 0),
                "Sales 90d": opp.get("sales90d", 0),
                "Sales 180d": opp.get("sales180d", 0),
                "Sales 365d": opp.get("sales365d", 0),
                "Custom Days Net Need": custom_days_display,
                "Net Need": net_need,
                "Stock Avg Price": stock_avg_display,
                "Baseline Price": f"‚Ç¨{opp.get('baseline_price', 0):.2f}",
                "Quote Price": f"‚Ç¨{opp.get('quote_price', 0):.2f}",
                "Price Diff %": price_diff_display,  # NEW COLUMN
                "Total Cost": f"‚Ç¨{opp.get('quote_price', 0) * get_safe_allocated_quantity(opp):.2f}",
                "Savings/Unit": f"‚Ç¨{opp.get('savings_per_unit', 0):.2f}",
                "Total Savings": f"‚Ç¨{opp.get('total_savings', 0):.2f}",
                "Allocated Qty": get_safe_allocated_quantity(opp),
                "Supplier Qty": qty_display,
                "Allocation": allocation_info,
                "Supplier": opp.get("supplier", "Unknown"),
                "Urgency": opp.get("urgency_score", ""),
                "Days Cover": f"{opp.get('days_of_cover', 0):.0f}",
                "Bestseller": opp.get("bestseller_stars", ""),
                "Price Comparison": (
                    " | ".join(price_details) if price_details else "N/A"
                ),
            }
        )

    # Display table - ENSURE ALL OPPORTUNITIES ARE SHOWN
    df = pd.DataFrame(table_data)

    # Configure Streamlit to show all rows
    st.write(f"**üìã Showing ALL {len(df)} opportunities:**")

    # Display the full table without any row limits
    st.dataframe(
        df,
        use_container_width=True,
        height=600,  # Set a fixed height to allow scrolling through all rows
    )

    # Add explanation for columns INCLUDING Priority column AND Price Difference %
    with st.expander("üìñ Column Guide"):
        st.write("**Priority Column:**")
        st.write(
            "‚Ä¢ **üî• P1 (Priority 1)**: Quote beats ALL 3 internal prices (bestbuy, supplier, stock avg)"
        )
        st.write(
            "‚Ä¢ **‚≠ê P2 (Priority 2)**: Quote beats operational prices (supplier + stock avg) but not bestbuy"
        )
        st.write(
            "‚Ä¢ **Highest impact opportunities** are Priority 1, followed by Priority 2"
        )
        st.write("")
        st.write("**NEW: Price Difference % Column:**")
        st.write(
            "‚Ä¢ **‚ÜìX.X%**: Shows savings percentage (baseline price vs quote price)"
        )
        st.write(
            "‚Ä¢ **Formula**: ((Baseline Price - Quote Price) / Baseline Price) √ó 100"
        )
        st.write("‚Ä¢ **‚Üì15.2%**: Quote is 15.2% cheaper than baseline price")
        st.write("‚Ä¢ **‚Üë5.1%**: Quote is 5.1% more expensive than baseline price")
        st.write(
            "‚Ä¢ **Baseline Price**: Best internal price used for comparison (varies by priority)"
        )
        st.write("")
        st.write("**Stock & Delivery Columns:**")
        st.write("‚Ä¢ **Current Stock**: Current inventory level")
        st.write("‚Ä¢ **Pending Delivery**: Quantity waiting from another supply source")
        st.write("‚Ä¢ **Sales 90d/180d/365d**: Historical sales for different periods")
        st.write(
            "‚Ä¢ **Custom Days Net Need**: Optional column showing Net Need for custom time period"
        )
        st.write(
            "  - Format: 'XXX (YYd)' where XXX is net need and YY is number of days"
        )
        st.write(
            "  - Extrapolates from closest available sales data (90d/180d/365d)"
        )
        st.write(
            "  - Shows 'N/A' if no custom days value entered in filter"
        )
        st.write(
            "‚Ä¢ **Net Need**: Calculated as Selected Sales Period - Current Stock - Pending Delivery"
        )
        st.write(
            "‚Ä¢ **Current calculation**: Based on the sales period filter you selected"
        )
        st.write("")
        st.write("**Days Cover column shows:**")
        st.write(
            "‚Ä¢ **Number of days**: How long Current Stock + Pending Delivery will last based on sales velocity"
        )
        st.write(
            "‚Ä¢ **Considers both current stock AND pending deliveries** in the calculation"
        )
        st.write("")
        st.write("**Stock Average Price column shows:**")
        st.write("‚Ä¢ **‚Ç¨X.XX**: The stock average price for this product")
        st.write("‚Ä¢ **N/A**: Stock average price not available for this product")
        st.write("")
        st.write("**Total Cost column shows:**")
        st.write("‚Ä¢ **‚Ç¨X.XX**: Quote Price √ó Allocated Quantity")
        st.write("‚Ä¢ **Total investment** required for each product allocation")
        st.write("")
        st.write(
            "**Note**: All sales columns are shown but only the selected sales period is used for Net Need calculation"
        )
        st.write("")
        st.write("**üÜï Updated Formula:**")
        st.write("‚Ä¢ **Net Need = Sales Period - Current Stock - Pending Delivery**")
        st.write("‚Ä¢ **Days Cover = (Current Stock + Pending Delivery) √∑ Daily Sales**")
        st.write(
            "‚Ä¢ **Price Diff % = ((Baseline Price - Quote Price) / Baseline Price) √ó 100**"
        )
        st.write(
            "‚Ä¢ **This ensures accurate calculations considering expected deliveries**"
        )

    # Show split order details if any
    if split_orders > 0:
        show_split_order_analysis(opportunities)


def show_enhanced_allocation_summary(engine):
    """Show summary metrics with allocation breakdown and stock average comparison - UPDATED: Only Priority 1 and 2"""

    try:
        summary = engine.get_summary()
    except:
        # Fallback calculation if get_summary fails
        opportunities = engine.opportunities if hasattr(engine, "opportunities") else []
        summary = {
            "total_opportunities": len(opportunities),
            "total_potential_savings": sum(
                opp.get("total_savings", 0) for opp in opportunities
            ),
            "high_urgency_count": sum(
                1 for opp in opportunities if opp.get("urgency_score") == "High"
            ),
            "bestseller_opportunities": sum(
                1 for opp in opportunities if opp.get("is_bestseller", False)
            ),
            "priority_1_count": sum(
                1 for opp in opportunities if opp.get("priority") == 1
            ),
            "priority_2_count": sum(
                1 for opp in opportunities if opp.get("priority") == 2
            ),
            # REMOVED: priority_3_count
            "split_orders_count": sum(
                1 for opp in opportunities if opp.get("is_split_order", False)
            ),
            "single_orders_count": len(opportunities)
            - sum(1 for opp in opportunities if opp.get("is_split_order", False)),
        }

    # Enhanced cost calculations including stock average comparison
    if hasattr(engine, "opportunities") and engine.opportunities:
        total_baseline_cost = 0
        total_quote_cost = 0
        total_stock_avg_cost = 0  # NEW: Stock average based cost

        for opp in engine.opportunities:
            allocated_qty = get_safe_allocated_quantity(opp)
            baseline_price = opp.get("baseline_price", 0)
            quote_price = opp.get("quote_price", 0)

            # Calculate baseline and quote costs (existing logic)
            total_baseline_cost += baseline_price * allocated_qty
            total_quote_cost += quote_price * allocated_qty

            # NEW: Calculate stock average based cost
            price_breakdown = opp.get("price_breakdown", {})
            stock_avg_price = price_breakdown.get("stock_avg_price")
            supplier_price = price_breakdown.get("supplier_price")

            # Use stock average price, fallback to supplier price if not available
            reference_price = None
            if stock_avg_price is not None and stock_avg_price > 0:
                reference_price = stock_avg_price
            elif supplier_price is not None and supplier_price > 0:
                reference_price = supplier_price

            if reference_price is not None:
                total_stock_avg_cost += reference_price * allocated_qty

        # Calculate cost savings percentage vs baseline
        cost_savings_percentage = (
            ((total_baseline_cost - total_quote_cost) / total_baseline_cost * 100)
            if total_baseline_cost > 0
            else 0
        )

        # NEW: Calculate stock average comparison metrics
        stock_avg_absolute_difference = total_stock_avg_cost - total_quote_cost
        stock_avg_savings_percentage = (
            ((total_stock_avg_cost - total_quote_cost) / total_stock_avg_cost * 100)
            if total_stock_avg_cost > 0
            else 0
        )

        # Update summary with new calculations
        summary.update(
            {
                "total_baseline_cost": total_baseline_cost,
                "total_quote_cost": total_quote_cost,
                "cost_savings_percentage": cost_savings_percentage,
                "total_stock_avg_cost": total_stock_avg_cost,  # NEW
                "stock_avg_absolute_difference": stock_avg_absolute_difference,  # NEW
                "stock_avg_savings_percentage": stock_avg_savings_percentage,  # NEW
            }
        )
    else:
        summary.update(
            {
                "total_baseline_cost": 0,
                "total_quote_cost": 0,
                "cost_savings_percentage": 0,
                "total_stock_avg_cost": 0,
                "stock_avg_absolute_difference": 0,
                "stock_avg_savings_percentage": 0,
            }
        )

    # Enhanced cost breakdown with stock average comparison
    if summary.get("total_baseline_cost", 0) > 0:
        st.subheader("üí∞ Total Cost Comparison")

        # First row: Original baseline vs opportunity comparison
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric(
                "üìä Baseline Total Cost",
                f"‚Ç¨{summary['total_baseline_cost']:.2f}",
                help="Total cost if buying at your baseline prices (best of: stock avg, supplier, or best buy price based on priority)",
            )

        with col2:
            st.metric(
                "üéØ Opportunity Total Cost",
                f"‚Ç¨{summary['total_quote_cost']:.2f}",
                help="Total cost if buying at the quoted opportunity prices",
            )

        with col3:
            baseline_absolute_savings = (
                summary["total_baseline_cost"] - summary["total_quote_cost"]
            )
            st.metric(
                "üíµ Baseline Savings",
                f"‚Ç¨{baseline_absolute_savings:.2f}",
                f"{summary['cost_savings_percentage']:.1f}% vs baseline",
                help="Total money saved vs baseline prices",
            )

        # NEW: Second row - Stock Average comparison
        if summary.get("total_stock_avg_cost", 0) > 0:
            st.subheader("üìà Stock Average Price Comparison")
            col1, col2, col3 = st.columns(3)

            with col1:
                st.metric(
                    "üìä Stock Avg Total Cost",
                    f"‚Ç¨{summary['total_stock_avg_cost']:.2f}",
                    help="Total cost using stock average prices (fallback to supplier price when stock avg not available)",
                )

            with col2:
                st.metric(
                    "üéØ Opportunity Total Cost",
                    f"‚Ç¨{summary['total_quote_cost']:.2f}",
                    help="Total cost if buying at the quoted opportunity prices",
                )

            with col3:
                st.metric(
                    "üí∞ Stock Avg Savings",
                    f"‚Ç¨{summary['stock_avg_absolute_difference']:.2f}",
                    f"{summary['stock_avg_savings_percentage']:.1f}% vs stock avg",
                    help="Total money saved vs stock average prices",
                    delta_color=(
                        "normal"
                        if summary["stock_avg_absolute_difference"] >= 0
                        else "inverse"
                    ),
                )

            # Show comparison insight
            if summary["stock_avg_absolute_difference"] > 0:
                st.success(
                    f"‚úÖ **Stock Average Savings**: You could save ‚Ç¨{summary['stock_avg_absolute_difference']:.2f} "
                    f"({summary['stock_avg_savings_percentage']:.1f}%) compared to your current stock average pricing!"
                )
            elif summary["stock_avg_absolute_difference"] < 0:
                st.warning(
                    f"‚ö†Ô∏è **Higher than Stock Average**: Opportunities cost ‚Ç¨{abs(summary['stock_avg_absolute_difference']):.2f} "
                    f"({abs(summary['stock_avg_savings_percentage']):.1f}%) more than stock average pricing."
                )
            else:
                st.info(
                    "‚ÑπÔ∏è **Similar to Stock Average**: Opportunity prices are similar to stock average pricing."
                )

    # UPDATED: Priority breakdown row - Only Priority 1 and 2
    st.subheader("üéØ Priority Breakdown")
    col1, col2, col3 = st.columns(3)

    with col1:
        # priority_1_pct = (
        #    summary["priority_1_count"] / summary["total_opportunities"] * 100
        #    if summary["total_opportunities"] > 0
        #    else 0
        # )
        st.metric(
            "üî• Priority 1",
            summary.get("priority_1_count", 0),
            # f"{priority_1_pct:.1f}%",
            help="Better than ALL internal prices (bestbuy, supplier, stock avg)",
        )

    with col2:
        # priority_2_pct = (
        #    summary["priority_2_count"] / summary["total_opportunities"] * 100
        #    if summary["total_opportunities"] > 0
        #    else 0
        # )
        st.metric(
            "‚≠ê Priority 2",
            summary.get("priority_2_count", 0),
            # f"{priority_2_pct:.1f}%",
            help="Better than operational prices (supplier & stock avg) but not bestbuy",
        )

    with col3:
        # Show total qualified opportunities instead of Priority 3
        total_qualified = summary.get("priority_1_count", 0) + summary.get(
            "priority_2_count", 0
        )
        # qualification_rate = (
        #    (total_qualified / summary["total_opportunities"] * 100)
        #    if summary["total_opportunities"] > 0
        #    else 0
        # )
        st.metric(
            "‚úÖ Total Qualified",
            total_qualified,
            # f"{qualification_rate:.1f}%",
            help="Total opportunities meeting Priority 1 or 2 criteria (100% with quality focus)",
        )

    # Allocation breakdown row
    st.subheader("üîÑ Smart Allocation Breakdown")
    col1, col2, col3 = st.columns(3)

    with col1:
        # split_pct = (
        #    summary.get("split_orders_count", 0) / summary["total_opportunities"] * 100
        #    if summary["total_opportunities"] > 0
        #    else 0
        # )
        st.metric(
            "üîÑ Split Orders",
            summary.get("split_orders_count", 0),
            # f"{split_pct:.1f}%",
            help="Orders split across multiple suppliers due to quantity constraints",
        )

    with col2:
        # single_pct = (
        #    summary.get("single_orders_count", 0) / summary["total_opportunities"] * 100
        #    if summary["total_opportunities"] > 0
        #    else 0
        # )
        st.metric(
            "üì¶ Single Supplier",
            summary.get("single_orders_count", 0),
            # f"{single_pct:.1f}%",
            help="Orders fulfilled by single supplier (sufficient quantity)",
        )

    with col3:
        # Calculate average suppliers per EAN for split orders
        if hasattr(engine, "opportunities") and engine.opportunities:
            split_opportunities = [
                opp for opp in engine.opportunities if opp.get("is_split_order", False)
            ]
            if split_opportunities:
                # Group by EAN to count suppliers per product
                ean_supplier_counts = {}
                for opp in split_opportunities:
                    ean = opp.get("ean", "")
                    if ean not in ean_supplier_counts:
                        ean_supplier_counts[ean] = 0
                    ean_supplier_counts[ean] += 1

                avg_suppliers = (
                    sum(ean_supplier_counts.values()) / len(ean_supplier_counts)
                    if ean_supplier_counts
                    else 0
                )
                st.metric(
                    "üìä Avg Suppliers/Split",
                    f"{avg_suppliers:.1f}",
                    help="Average number of suppliers used per split order",
                )
            else:
                st.metric("üìä Avg Suppliers/Split", "0.0")
        else:
            st.metric("üìä Avg Suppliers/Split", "0.0")


def show_allocation_status(engine):
    """Show allocation verification status"""

    try:
        verification = engine.verify_allocation()

        with st.expander("üîç Smart Allocation Status"):
            col1, col2, col3, col4 = st.columns(4)

            with col1:
                st.metric(
                    "Total Opportunities", verification.get("total_opportunities", 0)
                )
            with col2:
                st.metric("Unique EAN Codes", verification.get("unique_eans", 0))
            with col3:
                st.metric("Split Orders", verification.get("split_orders", 0))
            with col4:
                st.metric("Single Orders", verification.get("single_orders", 0))

            if not verification.get("allocation_success", False):
                st.write("**Allocation Issues:**")
                for issue in verification.get("allocation_issues", []):
                    st.write(f"‚Ä¢ {issue}")
                st.warning(
                    "‚ö†Ô∏è Some products have quantity shortfalls even after smart allocation."
                )
            else:
                st.info(
                    "‚úÖ Smart allocation working correctly - all quantity constraints handled optimally"
                )

    except AttributeError:
        # Fallback if verify_allocation method doesn't exist
        with st.expander("üîç Allocation Status (Basic Check)"):
            st.info("‚ö†Ô∏è Advanced allocation verification not available")

            if hasattr(engine, "opportunities") and engine.opportunities:
                split_count = sum(
                    1
                    for opp in engine.opportunities
                    if opp.get("is_split_order", False)
                )
                single_count = len(engine.opportunities) - split_count

                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Total Opportunities", len(engine.opportunities))
                with col2:
                    st.metric("Split Orders", split_count)
                with col3:
                    st.metric("Single Orders", single_count)

    except Exception as e:
        st.warning(f"Could not verify allocation: {str(e)}")


def show_split_order_analysis(opportunities: List[Dict]):
    """Show detailed analysis of split orders"""

    split_opportunities = [
        opp for opp in opportunities if opp.get("is_split_order", False)
    ]

    if not split_opportunities:
        return

    with st.expander(
        f"üîÑ Split Order Analysis ({len(split_opportunities)} split entries)"
    ):
        # Group split orders by EAN
        split_ean_groups = {}
        for opp in split_opportunities:
            ean = opp.get("ean", "")
            if ean not in split_ean_groups:
                split_ean_groups[ean] = []
            split_ean_groups[ean].append(opp)

        st.write(
            f"**Split across {len(split_ean_groups)} products with quantity constraints**"
        )

        # Calculate split order metrics
        total_split_savings = sum(
            opp.get("total_savings", 0) for opp in split_opportunities
        )
        avg_suppliers_per_split = sum(
            len(group) for group in split_ean_groups.values()
        ) / len(split_ean_groups)

        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Products with Splits", len(split_ean_groups))
        with col2:
            st.metric("Avg Suppliers per Split", f"{avg_suppliers_per_split:.1f}")
        with col3:
            st.metric("Split Order Savings", f"‚Ç¨{total_split_savings:.2f}")

        # Show detailed split order breakdown
        split_details = []
        for ean, group in split_ean_groups.items():
            if len(group) <= 1:
                continue

            # Sort by rank
            sorted_group = sorted(group, key=lambda x: x.get("split_order_rank", 1))

            net_need = sorted_group[0].get(
                "original_net_need", sorted_group[0].get("net_need", 0)
            )
            total_allocated = sum(
                get_safe_allocated_quantity(opp) for opp in sorted_group
            )

            # Calculate blended cost
            total_cost = sum(
                opp.get("quote_price", 0) * get_safe_allocated_quantity(opp)
                for opp in sorted_group
            )
            blended_price = total_cost / total_allocated if total_allocated > 0 else 0

            # Best supplier cost (hypothetical)
            best_supplier = sorted_group[0]
            best_price = best_supplier.get("quote_price", 0)
            hypothetical_cost = best_price * net_need

            cost_difference = total_cost - hypothetical_cost
            cost_increase_pct = (
                (cost_difference / hypothetical_cost * 100)
                if hypothetical_cost > 0
                else 0
            )

            # Create supplier breakdown
            supplier_breakdown = []
            for opp in sorted_group:
                rank = opp.get("split_order_rank", 1)
                supplier = opp.get("supplier", "Unknown")
                qty = get_safe_allocated_quantity(opp)
                price = opp.get("quote_price", 0)
                percentage = (qty / net_need * 100) if net_need > 0 else 0
                supplier_breakdown.append(
                    f"#{rank}: {supplier} ({qty} units, {percentage:.1f}%, ‚Ç¨{price:.2f})"
                )

            split_details.append(
                {
                    "EAN": ean,
                    "Product": sorted_group[0].get("product_name", "Unknown")[:40],
                    "Net Need": net_need,
                    "Total Allocated": total_allocated,
                    "Fulfillment": (
                        f"{total_allocated/net_need*100:.1f}%"
                        if net_need > 0
                        else "100%"
                    ),
                    "Suppliers Used": len(sorted_group),
                    "Blended Price": f"‚Ç¨{blended_price:.2f}",
                    "Best Price": f"‚Ç¨{best_price:.2f}",
                    "Cost vs Best": f"+‚Ç¨{cost_difference:.2f} (+{cost_increase_pct:.1f}%)",
                    "Supplier Breakdown": " | ".join(supplier_breakdown),
                }
            )

        if split_details:
            st.dataframe(pd.DataFrame(split_details), use_container_width=True)

        # Cost analysis summary
        total_cost_difference = sum(
            float(detail["Cost vs Best"].split("+‚Ç¨")[1].split(" ")[0])
            for detail in split_details
            if "+‚Ç¨" in detail["Cost vs Best"]
        )

        if total_cost_difference > 0:
            st.warning(
                f"üí∞ **Split Order Premium**: ‚Ç¨{total_cost_difference:.2f} additional cost due to quantity constraints"
            )
            st.info(
                "üí° **Note**: This premium ensures full order fulfillment when best suppliers lack sufficient quantity"
            )


def show_enhanced_allocation_supplier_analysis(engine):
    """Show supplier performance analysis with allocation insights - UPDATED: Only Priority 1 and 2"""

    opportunities = engine.opportunities if hasattr(engine, "opportunities") else []

    if not opportunities:
        return

    with st.expander("üè¢ Supplier Performance Analysis (with Smart Allocation)"):
        try:
            supplier_stats = engine.analyze_supplier_performance()
        except:
            # Fallback calculation
            supplier_stats = {}
            for opp in opportunities:
                supplier = opp.get("supplier", "Unknown")
                if supplier not in supplier_stats:
                    supplier_stats[supplier] = {
                        "opportunity_count": 0,
                        "total_potential_savings": 0,
                        "split_order_count": 0,
                        "single_order_count": 0,
                        "primary_supplier_count": 0,
                        "priority_1_count": 0,
                        "priority_2_count": 0,
                        # REMOVED: priority_3_count
                    }

                supplier_stats[supplier]["opportunity_count"] += 1
                supplier_stats[supplier]["total_potential_savings"] += opp.get(
                    "total_savings", 0
                )

                # Count by priority - only 1 and 2
                if opp.get("priority") == 1:
                    supplier_stats[supplier]["priority_1_count"] += 1
                elif opp.get("priority") == 2:
                    supplier_stats[supplier]["priority_2_count"] += 1

                if opp.get("is_split_order", False):
                    supplier_stats[supplier]["split_order_count"] += 1
                    if opp.get("split_order_rank", 1) == 1:
                        supplier_stats[supplier]["primary_supplier_count"] += 1
                else:
                    supplier_stats[supplier]["single_order_count"] += 1

        if supplier_stats:
            supplier_data = []
            for supplier, stats in supplier_stats.items():
                avg_savings = (
                    stats["total_potential_savings"] / stats["opportunity_count"]
                    if stats["opportunity_count"] > 0
                    else 0
                )

                # Calculate allocation metrics
                split_percentage = (
                    stats.get("split_order_count", 0) / stats["opportunity_count"] * 100
                    if stats["opportunity_count"] > 0
                    else 0
                )

                primary_rate = (
                    stats.get("primary_supplier_count", 0)
                    / stats.get("split_order_count", 1)
                    * 100
                    if stats.get("split_order_count", 0) > 0
                    else 0
                )

                # Calculate quality metrics - only Priority 1 and 2
                total_qualified = stats.get("priority_1_count", 0) + stats.get(
                    "priority_2_count", 0
                )
                priority_1_rate = (
                    (stats.get("priority_1_count", 0) / total_qualified * 100)
                    if total_qualified > 0
                    else 0
                )

                # NEW: Calculate cost comparison metrics for this supplier
                total_cost_stock_avg = 0
                total_cost_supplier = 0
                items_with_stock_avg = 0

                # Find all opportunities for this supplier to calculate costs
                supplier_opportunities = [
                    opp for opp in opportunities if opp.get("supplier") == supplier
                ]

                for opp in supplier_opportunities:
                    allocated_qty = get_safe_allocated_quantity(opp)
                    quote_price = opp.get("quote_price", 0)
                    total_cost_supplier += quote_price * allocated_qty

                    # Get stock average price from price breakdown
                    price_breakdown = opp.get("price_breakdown", {})
                    stock_avg_price = price_breakdown.get("stock_avg_price")

                    if stock_avg_price is not None and stock_avg_price > 0:
                        total_cost_stock_avg += stock_avg_price * allocated_qty
                        items_with_stock_avg += 1

                # Calculate savings percentage
                savings_percentage = 0
                if total_cost_stock_avg > 0:
                    savings_percentage = (
                        (total_cost_stock_avg - total_cost_supplier)
                        / total_cost_stock_avg
                    ) * 100

                supplier_data.append(
                    {
                        "Supplier": supplier,
                        "Total Opportunities": stats["opportunity_count"],
                        "üî• Priority 1": stats.get("priority_1_count", 0),
                        "‚≠ê Priority 2": stats.get("priority_2_count", 0),
                        "P1 Rate": f"{priority_1_rate:.1f}%",
                        "üîÑ Split Orders": stats.get("split_order_count", 0),
                        "üì¶ Single Orders": stats.get("single_order_count", 0),
                        "Split %": f"{split_percentage:.1f}%",
                        "Primary in Splits": f"{primary_rate:.1f}%",
                        "Total Savings": f"‚Ç¨{stats['total_potential_savings']:.2f}",
                        "Avg Savings": f"‚Ç¨{avg_savings:.2f}",
                        "Total Cost Stock Avg": (
                            f"‚Ç¨{total_cost_stock_avg:.2f}"
                            if items_with_stock_avg > 0
                            else "N/A"
                        ),
                        "Total Cost Supplier": f"‚Ç¨{total_cost_supplier:.2f}",
                        "% Savings": (
                            f"{savings_percentage:.1f}%"
                            if items_with_stock_avg > 0
                            else "N/A"
                        ),
                    }
                )

            # Sort by total potential savings
            supplier_df = pd.DataFrame(supplier_data)
            supplier_df["_sort_value"] = [
                stats["total_potential_savings"] for stats in supplier_stats.values()
            ]
            supplier_df = supplier_df.sort_values("_sort_value", ascending=False).drop(
                "_sort_value", axis=1
            )

            st.dataframe(supplier_df, use_container_width=True)

            # Show allocation insights
            st.write("**üìä Quality & Allocation Insights:**")

            total_split_opportunities = sum(
                stats.get("split_order_count", 0) for stats in supplier_stats.values()
            )
            total_single_opportunities = sum(
                stats.get("single_order_count", 0) for stats in supplier_stats.values()
            )
            total_priority_1 = sum(
                stats.get("priority_1_count", 0) for stats in supplier_stats.values()
            )
            total_priority_2 = sum(
                stats.get("priority_2_count", 0) for stats in supplier_stats.values()
            )

            if total_split_opportunities > 0:
                st.write(
                    f"‚Ä¢ **{total_split_opportunities}** opportunities required split orders due to quantity constraints"
                )
                st.write(
                    f"‚Ä¢ **{total_single_opportunities}** opportunities fulfilled by single suppliers"
                )

                # Find most reliable suppliers (high primary rate in splits)
                reliable_suppliers = [
                    (
                        supplier,
                        stats.get("primary_supplier_count", 0)
                        / stats.get("split_order_count", 1)
                        * 100,
                    )
                    for supplier, stats in supplier_stats.items()
                    if stats.get("split_order_count", 0) > 0
                ]
                reliable_suppliers.sort(key=lambda x: x[1], reverse=True)

                if reliable_suppliers:
                    best_supplier, best_rate = reliable_suppliers[0]
                    st.write(
                        f"‚Ä¢ **Most reliable primary supplier**: {best_supplier} ({best_rate:.1f}% primary rate in splits)"
                    )

            # Quality insights
            st.write(
                f"‚Ä¢ **Quality Distribution**: {total_priority_1} Priority 1 (maximum impact), {total_priority_2} Priority 2 (operational improvement)"
            )

            if supplier_stats:
                # Find highest quality supplier
                quality_suppliers = [
                    (supplier, stats.get("priority_1_count", 0))
                    for supplier, stats in supplier_stats.items()
                    if stats.get("priority_1_count", 0) > 0
                ]
                quality_suppliers.sort(key=lambda x: x[1], reverse=True)

                if quality_suppliers:
                    best_quality_supplier, p1_count = quality_suppliers[0]
                    st.write(
                        f"‚Ä¢ **Highest impact supplier**: {best_quality_supplier} ({p1_count} Priority 1 opportunities)"
                    )


def show_allocation_export_options(opportunities: List[Dict]):
    """Show export options with allocation data and stock average prices"""

    if not opportunities:
        return

    st.subheader("üíæ Export Smart Allocation Results")

    col1, col2 = st.columns(2)

    with col1:
        if st.button("üìÑ Download Smart Allocation CSV"):
            # Helper function to clean text of icons and symbols
            def clean_text(text):
                if pd.isna(text) or text == "":
                    return ""
                text_str = str(text)
                # Remove emojis and special symbols, keep only alphanumeric, spaces, and basic punctuation
                import re

                cleaned = re.sub(r"[^\w\s\-\.\(\)]", "", text_str)
                return cleaned.strip()

            # Helper function to format price with comma decimal separator
            def format_price_comma(price_value):
                if pd.isna(price_value) or price_value == "" or price_value == 0:
                    return ""
                try:
                    # Convert to float and format with comma as decimal separator
                    float_val = float(price_value)
                    return f"{float_val:.2f}".replace(".", ",")
                except (ValueError, TypeError):
                    return ""

            # Helper function to ensure numeric values
            def ensure_numeric(value):
                if pd.isna(value) or value == "":
                    return 0
                try:
                    return float(value) if isinstance(value, (int, float, str)) else 0
                except (ValueError, TypeError):
                    return 0

            # Prepare cleaned data for export
            export_data = []
            for opp in opportunities:
                # Clean and format all data
                export_row = {
                    # Basic identification
                    "Priority": ensure_numeric(opp.get("priority", 0)),
                    "Priority_Label": clean_text(opp.get("priority_label", "")),
                    "EAN": pad_ean_code(opp.get("ean", "")),
                    "Product_Name": clean_text(opp.get("product_name", "")),
                    "Brand": clean_text(opp.get("brand", "")),
                    # Quantities (as integers)
                    "Current_Stock": int(ensure_numeric(opp.get("current_stock", 0))),
                    "Sales_90d": int(ensure_numeric(opp.get("sales90d", 0))),
                    "Sales_180d": int(ensure_numeric(opp.get("sales180d", 0))),
                    "Sales_365d": int(ensure_numeric(opp.get("sales365d", 0))),
                    "Net_Need": int(ensure_numeric(opp.get("net_need", 0))),
                    "Calculated_With_Period": clean_text(
                        opp.get("calculated_with_period", "sales90d")
                    ),
                    "Allocated_Quantity": int(
                        ensure_numeric(get_safe_allocated_quantity(opp))
                    ),
                    "Supplier_Quantity_Available": (
                        int(ensure_numeric(opp.get("supplier_quantity", 0)))
                        if opp.get("supplier_quantity") is not None
                        else ""
                    ),
                    # Prices (with comma decimal separator, no ‚Ç¨ symbol)
                    "Baseline_Price": format_price_comma(opp.get("baseline_price", 0)),
                    "Quote_Price": format_price_comma(opp.get("quote_price", 0)),
                    "Savings_Per_Unit": format_price_comma(
                        opp.get("savings_per_unit", 0)
                    ),
                    "Total_Savings": format_price_comma(opp.get("total_savings", 0)),
                    "Total_Cost": format_price_comma(
                        opp.get("quote_price", 0) * get_safe_allocated_quantity(opp)
                    ),
                    # Stock average price comparison
                    "Stock_Avg_Price": format_price_comma(
                        opp.get("price_breakdown", {}).get("stock_avg_price", "")
                    ),
                    "BestBuy_Price": format_price_comma(
                        opp.get("price_breakdown", {}).get("best_buy_price", "")
                    ),
                    "Supplier_Price": format_price_comma(
                        opp.get("price_breakdown", {}).get("supplier_price", "")
                    ),
                    # Boolean flags (True/False without icons)
                    "Beats_Stock_Avg": opp.get("price_breakdown", {}).get(
                        "beats_stock_avg", False
                    ),
                    "Beats_BestBuy": opp.get("price_breakdown", {}).get(
                        "beats_best_buy", False
                    ),
                    "Beats_Supplier": opp.get("price_breakdown", {}).get(
                        "beats_supplier", False
                    ),
                    "Is_Bestseller": opp.get("is_bestseller", False),
                    "Is_Split_Order": opp.get("is_split_order", False),
                    # Text fields (cleaned)
                    "Supplier": clean_text(opp.get("supplier", "")),
                    "Urgency_Score": clean_text(opp.get("urgency_score", "")),
                    "Allocation_Type": clean_text(
                        opp.get("allocation_type", "single_supplier")
                    ),
                    # Numeric percentages and rankings
                    "Split_Order_Rank": (
                        int(ensure_numeric(opp.get("split_order_rank", 0)))
                        if opp.get("split_order_rank")
                        else ""
                    ),
                    "Split_Percentage": ensure_numeric(
                        opp.get("split_percentage", 100.0)
                    ),
                    "Remaining_Need_After": int(
                        ensure_numeric(opp.get("remaining_need_after", 0))
                    ),
                    # Stock average savings analysis
                    "Stock_Avg_Savings_Per_Unit": format_price_comma(
                        opp.get("price_breakdown", {}).get("stock_avg_price", 0)
                        - opp.get("quote_price", 0)
                        if opp.get("price_breakdown", {}).get("stock_avg_price")
                        else ""
                    ),
                    "Stock_Avg_Total_Savings": format_price_comma(
                        (
                            opp.get("price_breakdown", {}).get("stock_avg_price", 0)
                            - opp.get("quote_price", 0)
                        )
                        * get_safe_allocated_quantity(opp)
                        if opp.get("price_breakdown", {}).get("stock_avg_price")
                        else ""
                    ),
                    # Metadata
                    "Analysis_Date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "Quality_Focus_Mode": "Priority_1_and_2_Only",
                }

                export_data.append(export_row)

            # Create DataFrame and export with comma delimiter
            df = pd.DataFrame(export_data)

            # Ensure numeric columns are properly typed
            numeric_columns = [
                "Priority",
                "Current_Stock",
                "Sales_90d",
                "Sales_180d",
                "Sales_365d",
                "Net_Need",
                "Allocated_Quantity",
                "Split_Order_Rank",
                "Split_Percentage",
                "Remaining_Need_After",
            ]

            for col in numeric_columns:
                if col in df.columns:
                    df[col] = pd.to_numeric(df[col], errors="coerce").fillna(0)

            # Create CSV with semicolon delimiter and proper formatting
            csv_content = df.to_csv(index=False, sep=";", decimal=",", encoding="utf-8")
            filename = f"smart_allocation_with_sales_periods_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"

            st.download_button(
                label="üíæ Download Smart Allocation CSV",
                data=csv_content,
                file_name=filename,
                mime="text/csv",
                help="Clean CSV with semicolon delimiters, no icons, prices with comma decimals, includes all sales periods",
            )

    with col2:
        if st.button("üè¢ Download All Supplier Order CSVs"):
            # Group opportunities by supplier
            supplier_groups = {}
            for opp in opportunities:
                supplier = opp.get("supplier", "Unknown_Supplier")
                if supplier not in supplier_groups:
                    supplier_groups[supplier] = []
                supplier_groups[supplier].append(opp)

            if supplier_groups:
                import zipfile
                import io

                # Create a ZIP file containing all supplier CSVs
                zip_buffer = io.BytesIO()
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

                with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
                    total_products = 0
                    total_units = 0

                    for (
                        supplier_name,
                        supplier_opportunities,
                    ) in supplier_groups.items():
                        # Prepare CSV data for this supplier
                        supplier_csv_data = []
                        supplier_quantity = 0

                        for opp in supplier_opportunities:
                            allocated_qty = get_safe_allocated_quantity(opp)
                            supplier_quantity += allocated_qty
                            total_units += allocated_qty
                            total_products += 1

                            supplier_csv_data.append(
                                {
                                    "EAN": pad_ean_code(opp.get("ean", "")),
                                    "Product_Name": opp.get("product_name", ""),
                                    "Brand": opp.get("brand", ""),
                                    "Quantity": allocated_qty,
                                    "Quote_Price": f"{opp.get('quote_price', 0):.2f}".replace(
                                        ".", ","
                                    ),
                                    "Total_Cost": f"{opp.get('quote_price', 0) * allocated_qty:.2f}".replace(
                                        ".", ","
                                    ),
                                }
                            )

                        # Create CSV content
                        supplier_df = pd.DataFrame(supplier_csv_data)
                        csv_content = supplier_df.to_csv(
                            index=False, sep=";", decimal=","
                        )

                        # Clean supplier name for filename
                        safe_supplier_name = "".join(
                            c
                            for c in supplier_name
                            if c.isalnum() or c in (" ", "-", "_")
                        ).rstrip()
                        safe_supplier_name = safe_supplier_name.replace(" ", "_")

                        filename = (
                            f"supplier_order_{safe_supplier_name}_{timestamp}.csv"
                        )

                        # Add CSV to ZIP file
                        zip_file.writestr(filename, csv_content)

                # Prepare ZIP file for download
                zip_buffer.seek(0)
                zip_filename = f"all_supplier_orders_with_sales_data_{timestamp}.zip"

                st.success(
                    f"‚úÖ Created ZIP file with {len(supplier_groups)} supplier CSV files"
                )
                st.info(
                    f"üì¶ **Package Contents**: {total_products} total products, {total_units} total units across {len(supplier_groups)} suppliers"
                )

                # Download button for the ZIP file
                st.download_button(
                    label=f"üì¶ Download ZIP ({len(supplier_groups)} suppliers)",
                    data=zip_buffer.getvalue(),
                    file_name=zip_filename,
                    mime="application/zip",
                    help=f"Downloads {len(supplier_groups)} CSV files with sales period data in a single ZIP archive",
                )

                # Show breakdown of what's included
                with st.expander("üìã ZIP File Contents Preview"):
                    zip_contents = []
                    for (
                        supplier_name,
                        supplier_opportunities,
                    ) in supplier_groups.items():
                        safe_supplier_name = "".join(
                            c
                            for c in supplier_name
                            if c.isalnum() or c in (" ", "-", "_")
                        ).rstrip()
                        safe_supplier_name = safe_supplier_name.replace(" ", "_")

                        supplier_quantity = sum(
                            get_safe_allocated_quantity(opp)
                            for opp in supplier_opportunities
                        )

                        zip_contents.append(
                            {
                                "File Name": f"supplier_order_{safe_supplier_name}_{timestamp}.csv",
                                "Supplier": supplier_name,
                                "Products": len(supplier_opportunities),
                                "Total Units": supplier_quantity,
                                "Columns": "EAN, Product_Name, Brand, Quantity, Quote_Price, Total_Cost",
                            }
                        )

                    st.dataframe(pd.DataFrame(zip_contents), use_container_width=True)

                st.info(
                    f"üí° **Tip**: Extract the ZIP file to get individual CSV files for each supplier, ready for ordering"
                )
            else:
                st.info("No supplier data available for export")

    # Show export summary with quality focus info and sales period data
    split_count = sum(1 for opp in opportunities if opp.get("is_split_order", False))
    single_count = len(opportunities) - split_count
    stock_avg_available = sum(
        1
        for opp in opportunities
        if opp.get("price_breakdown", {}).get("stock_avg_price") is not None
    )

    priority_1_count = sum(1 for opp in opportunities if opp.get("priority") == 1)
    priority_2_count = sum(1 for opp in opportunities if opp.get("priority") == 2)

    # Show supplier breakdown in summary
    supplier_count = len(set(opp.get("supplier", "") for opp in opportunities))

    # Show which sales period was used
    sales_period_used = "sales90d"  # Default
    if opportunities:
        sales_period_used = opportunities[0].get("calculated_with_period", "sales90d")

    period_display = {
        "sales90d": "90 days",
        "sales180d": "180 days",
        "sales365d": "365 days",
    }.get(sales_period_used, sales_period_used)
